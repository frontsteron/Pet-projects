# Git - одна из сестем контроля версий

* ## Подготавливаем и настраиваем
1. ### Заходим на <code>[оффициальный сайт](https://git-scm.com)</code>, <code>[скачиваем Git](https://git-scm.com/downloads)</code> для Вашей ОС и устанавливаем.

2. ### Перед созданием нового проекта рекомендуется произвести следующую настройку/глобальную конфигурацию. 
```Shell
git config --global user.name "First name, last name"
git config --global user.email "email@email.com"
```

3. ### Потом заходим в папку с проектом и призводим инициализацию проекта/репозитория для отслеживания.
```Shell
git init
git init <folder> # создать новый проект в указанной директории
```

4. ### Либо делаем клонирование репозитория из удаленного.
```Shell
git clone <url>
git clone <url> <folder>
```
### Где **folder** не обязательно, это имя локального каталога.
---

* ## Делаем коммит

1. ### Добавляем файл на **commit** кандидат.
```Shell
git add <file> # вводим первые 2 буквы названия файла после git add и нажимаем tab
git add . # добавляем все файлы
```

2. ### Сохраняем/фиксируем и комментириуем изменения файла.
```Shell
git commit -m "Comment"
```
* ### После изменения файла делаем 2 этих пункта.
3. ### gitk - редактор коммитов, так можем посмотреть коммиты.
---

* ## Смотрим коммит
```Shell
git show <commit>
```
---

* ## Смотрим/подключаем/отключаем удалённый репозиторий
```Shell 
git remote remove show origin # смотрим информацию про удалённый репозиторий
git remote add origin <url> # подключаем удаленный репозиторий
git remote
git remote -v # инормация о путях к удаленным репозиториям
git remote remove origin # отключает удаленный репозиторий
```

---
* ## Отправляем изменения в удалённый репозиторий
```Shell
git push <remote-name> <branch-name>
# например
git push -u origin <branch>
```

* ## Получение изменений из удалённого репозитория
```Shell
git fetch <remote> # безопасное
git fetch --all # затягивает все изменения
git pull # не безопасное
```

---
* ## История коммитов(*всех изменений*)
```Shell
git log # история коммитов
git log --oneline --all --graph # история в всех коммитов в одну строку с графиком
git log --pretty=oneline # история в одну строку
git log -p # показывает разницу, внесённую в каждый коммит
git log origin/<branch-name(remote)> ^<branch-name(local)> # смотрим изменения в удаленной ветке без слияния с локальной
git log --graph --oneline --decorate # смотрим историю коммитов в виде графика для текущей ветке
```

---
* ## Просмотр индексированных и неиндексированных изменений
```Shell
git diff
git diff <commit>
```

---
* ## Проверяем состояние

1. ### Проверяем состояние **Git** репозитория.
```Shell
git status
git status -s # сокращенный вариант
```

---
* ## Игнорирование отслежевания
### Хорошая практика заключается в настройке файла **.gitignore** до начала работы с проектом, вот пример такого файла.
```Shell
# Исключить все файлы с расширением .a
*.a

# Но отслеживать файл name_file.a даже если он подпадает под исключение выше
!name_file.a

# Исключить файл FILE в корневом каталоге, но не файл в другой директории subdir/FILE
/FILE

# Игнорировать все файлы в каталоге folder/
folder/

# Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt
doc/*.txt

# Игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt

# Каталоги автоматически создаваемую документацию
log, tmp, pid; 
```

---
* ## Удаление файлов из отслеживаемых файлов/из вашего индекса 
```Shell
git rm
```

### Удаление файла из индекса, но оставив его в рабочем каталоге
```Shell
git rm --cached
```

---
* ## Перемещение/переименование файла
```Shell
git mv file_from file_to
git mv file_from /folder

# аналогично

git rm file_from
git add file_to
```

---
* ## Возвращение к коммиту
```Shell
git checkout *hash from the commit histor*
git checkout master // возвращаемся на ветку master
```

---
* ## Отмена индексации
```Shell
git reset HEAD(либо hash) <file> # только подготовленный файл
git checkout <file>
# или
git commit --amend  -m "new_comment" # редактирует сообщение предыдущего коммита
# или более новый вариант
git restore
git restore --staged <file>
```

---
* ## Отмена коммита/изменений
```Shell
git revert HEAD # возарщаемся к последнему коммиту в нашей ветке(безопасно)
git checkout -- <file>
```
### Команда **git revert** отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда **git reset**.

---
* ## Просмотр удалённых репозиториев
```Shell
git remote
git remote -v // просмотреть адреса для чтения и записи, привязанные к репозиторию
```
---
* ## Слияние локального с удаленным реаозиторием
```Shell
git merge origin
```
---
* ## Удаление и переименование удалённых репозиториев
```Shell
git remote rename <old_name> <new_name>
git remote rm
```
---
* ## Создаем/переименовываем ветку, переходим в неё и удаляем
```Shell
git branch <branch_name> # создает
git branch -M <branch_name> # создаем и переходим на ветку <branch_name>
git branch -m <branch_name> <branch_rename> # переименовывает ветку branch_name в branch_rename
git checkout -b <branch_name> # переключение к ней
git branch -d <branch_name> # удаляет локальную
git push origin --delete <branch_name> # удаляет удаленную
```
---
* ## Отправка ветки на удаленный репозиторий
```Shell
git push -u origin <new_branch> # публикации локальных изменений в удаленный репозиторий основной ветви
git push --delete origin existing_branch # удаление удалённой ветки
```
---
* ## Теги 
### Аннотированные теги:
```Shell
git tag -a v3.4 -m "my version 3.4"
```

### С помощью команды **git show** вы можете посмотреть данные тега вместе с коммитом.
```Shell
git show v3.4
```

### Легковесные теги:
```Shell
git tag v3.4-lw
```

### Отправка тегов, через **git push** они не отправляются
```Shell
git push origin <tagname>
```

### Удаление тегов из локальных и из внешних репозиториев
```Shell
git tag -d <tagname> # локальный

git push origin --delete <tagname> # внешний
```

### Переход на тег
```Shell
git checkout -b <branch_name> v3.4
```
---
* ## Ускоряем работу с Git
### Если вы не хотите печатать каждую команду для **Git** целиком, вы легко можете настроить псевдонимы (*alias*) для любой команды с помощью **git config**. Вот несколько примеров псевдонимов, которые вы, возможно, захотите задать:
```Shell
git config --global alias.ch checkout
git config --global alias.br branch
git config --global alias.cm commit
git config --global alias.st status
```
### Это означает, что, вместо ввода **git commit**, вам достаточно набрать только **git cm**. По мере освоения **Git** вам, вероятно, придётся часто пользоваться и другими командами. В этом случае без колебаний создавайте новые псевдонимы.
---

## Это были далеко не все команды, для вызова справки по командам можно набрать флаг **help**, после команды про которую хотим узнать
```Shell
git <command> --help
```

# А вот так работаем с командной строкой
## Смотрим наш текущий рабочий каталог
```
pwd
```
## Смотрим список файлов
```
ls
```
## Изменяем текущий рабочий каталог
```
cd <dir>
cd..
```
## Создаем папку **folder**
```
mkdir <folder>
```
## Создаем файл
```
ni <file>
touch <file>
```
## Копируем файл
```Shell
cp <dir> <file>
```
## Переименовываем/перемещаем файл
```Shell
mv <file> <rename_file>
```
## Записываем в файл
```Shell
echo <text> > <file>
```

## Просматриваем содержимое файла
```Shell
cat <file>
```
## Удаляем файл/директорию
```Shell
rm <file>
rm -R <dir>
```