# Git - одна из сестем контроля версий

* ## Подготавливаем и настраиваем
1. ### Заходим на <code>[оффициальный сайт](https://git-scm.com)</code>, <code>[скачиваем Git](https://git-scm.com/downloads)</code> для Вашей ОС и устанавливаем.

2. ### Перед созданием нового проекта рекомендуется произвести следующую настройку/глобальную конфигурацию. 
```Shell
git config --global user.name "First name, last name"
git config --global user.email "email@email.com"
```

3. ### Потом заходим в папку с проектом и призводим инициализацию проекта/репозитория для отслеживания.
```Shell
git init
git init <folder> # создать новый проект в указанной директории
```

4. ### Либо делаем клонирование репозитория из удаленного.
```Shell
git clone <url>
git clone <url> <folder>
```
### Где **folder** не обязательно, это имя локального каталога.
---

* ## Делаем коммит

1. ### Добавляем файл на **commit** кандидат.
```Shell
git add <file> # вводим первые 2 буквы названия файла после git add и нажимаем tab
git add . # добавляем все файлы
```

2. ### Сохраняем/фиксируем и комментириуем изменения файла.
```Shell
git commit -m "Comment"
```
* ### После изменения файла делаем 2 этих пункта.
### *PS.В коммитах только готовые/завершенные задачи или коммит за определенное время. Но коммит делаем минимум 1 раз в день. Вот здесь написано как их можно писать* - [conventionalcommits.org](https://www.conventionalcommits.org/). *Это одна из версий, но вообще коммиты должны отражать суть сожержимого и соответствовать стандартам в компании.*

3. ### gitk - редактор коммитов, так можем посмотреть коммиты.
---

* ## Смотрим коммит
```Shell
git show <commit>
```
---

* ## Смотрим/подключаем/отключаем удалённый репозиторий
```Shell 
git remote remove show origin # смотрим информацию про удалённый репозиторий
git remote add origin <url> # подключаем удаленный репозиторий
git remote
git remote -v # просмотреть адреса для чтения и записи, привязанные к репозиторию
git remote remove origin # отключает удаленный репозиторий(удалем ссылку из локального на удаленные репозиторий)
```

---
* ## Отправляем изменения в удалённый репозиторий
```Shell
git push <remote-name> <branch-name>
# например
git push -u origin <branch>
# или
git push --set-upstream origin <branch>
```

* ## Получение изменений из удалённого репозитория
```Shell
git fetch <remote> # безопасное
git fetch --all # затягивает все изменения
git pull # не безопасное
```

---
* ## История коммитов(*всех изменений*)
```Shell
git log # история коммитов
git log --oneline --all --graph # история в всех коммитов в одну строку с графиком
git log --pretty=oneline # история в одну строку
git log -p # показывает разницу, внесённую в каждый коммит
git log origin/<branch-name(remote)> ^<branch-name(local)> # смотрим изменения в удаленной ветке без слияния с локальной
git log --graph --oneline --decorate # смотрим историю коммитов в виде графика для текущей ветке
```

---
* ## Просмотр индексированных и неиндексированных изменений
```Shell
git diff
git diff <file_0> # or more <file_1>
git diff <commit_0> <commit_1> # or more a <file>, on to see a chenges on <file>
git blame # отображение метаданных автора, связанных со строками, которые были внесены в файл при коммите
```

---
* ## Проверяем состояние **Git** репозитория.
```Shell
git status
git status -s # сокращенный вариант
```

---
* ## Игнорирование отслежевания
### Хорошая практика заключается в настройке файла **.gitignore** до начала работы с проектом, вот пример такого файла.
```Shell
# Исключем файл
<file>

# Исключить все файлы с расширением .log
*.log

# Игнорировать все файлы в каталоге folder/
folder/

# Но отслеживать файл file.log в папке folder даже если он подпадает под исключение выше
folder/*.log
!folder/file.log

# Каталоги автоматически создаваемую документацию
log, tmp, pid; 
```
## Не рекомендуется хранить в Git-репозиториях:
* ### Лог-файлы (*логи*),
* ### Файлы, загруженные пользователями,
* ### Служебные файлы сред разработки,
* ### Внешние библиотеки,
* ### Файлы локальной конфигурации,
* ### Файлы операционной системы,
* ### Очень большие файлы,
## После добавления файлов в игнорируемые, удаяляем их из индекса
```Shell
git rm --cached <file> # удаляет файл из индекса, но оставляет в каталоге
git rm # удаление файлов из отслеживаемых файлов/из вашего индекса
```

---
* ## Перемещение/переименование файла
```Shell
git mv <file_from> <file_to>
git mv <file> /folder

# аналогично

git rm --cashed <file>
git add <file_to>
```

---
* ## Возвращение к коммиту
```Shell
git checkout <commit> # more <file>
git checkout master # возвращаемся на ветку master
git blame # это команда, которая используется для отображения редакции и автора каждой строки файла
```

---
* ## Отмена индексации
```Shell
git reset HEAD(либо hash) <file> # только подготовленный файл
git checkout <file>
# или
git commit --amend  -m "new_comment" # редактирует сообщение предыдущего коммита
# или более новый вариант
git restore <file> # отмена изменений
git restore --staged <file> # возвращаем из индекса
git clean -f # удаляет все незакомиченные изменения безвозвратно
```

---
* ## Отмена коммита/изменений
```Shell
git revert HEAD # возарщаемся к последнему коммиту в нашей ветке(безопасно)
git revert <commit> # отменяет только этот коммит
git checkout -- <file> # отменяет все изменений в рабочем каталоге для определенного файла и возвращает его обратно к последней зафиксированной версии файла
git revert --abort # отменяет все изменения, внесенные частично завершенной операцией `git revert`, и возвращает репозиторий в предыдущее состояние
git reset --hard <commit> # удаляет безвозвратно все не закомиченные изменения(осторожно!)
```
### Команда **git revert** отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда **git reset**.

---
* ## Слияние локального с удаленным реаозиторием и отмена слияния
```Shell
git merge <branch> # слияние
git merge --abort # отмена слияния
git merge --allow-unrelated-histories # объедининяет два несвязанных репозитория Git
git rebase <branch> # изменяем родительский коммит
git cherry-pick <commit> # перемещаем коммит в текущую ветку
```
---
* ## Удаление и переименование удалённых репозиториев
```Shell
git remote rename <old_name> <new_name>
git remote rm
```
---
* ## Создаем/переименовываем ветку, переходим в неё и удаляем
```Shell
git branch <branch_name> # создает
git branch -M <branch_name> # создаем и переходим на ветку <branch_name>
git branch -m <branch_name> <branch_rename> # переименовывает ветку branch_name в branch_rename
git checkout -b <branch_name> # переключение к ней
git branch -d <branch_name> # удаляет локальную
git push origin --delete <branch_name> # удаляет удаленную
```
---
* ## Отправка ветки на удаленный репозиторий
```Shell
git push -u origin <new_branch> # публикации локальных изменений в удаленный репозиторий основной ветви
git push --delete origin existing_branch # удаление удалённой ветки
```
### 1. **Git flow** - **master**/**main**(*основная ветка*) - **dev**/**devel**/**develop**(*ветка разработки*) - **test**/**stating**(*ветка для тестировщиков*) - **prod**/**production**(*ветка для продакшн релизов*) - **fixes**/**hot-fixes**/**hotfixes**(*изменения в обход веток*).
### 2. **TBD** - имя ветки: начало с номера задачи, латинскими буквами в нижнем регистре, суть задачи в этой ветке.
---
* ## Теги 
### Аннотированные теги:
```Shell
git tag -a v3.4 -m "my version 3.4"
```

### С помощью команды **git show** вы можете посмотреть данные тега вместе с коммитом.
```Shell
git show v3.4
```

### Легковесные теги:
```Shell
git tag v3.4-lw
```

### Отправка тегов, через **git push** они не отправляются
```Shell
git push origin <tagname>
```

### Удаление тегов из локальных и из внешних репозиториев
```Shell
git tag -d <tagname> # локальный

git push origin --delete <tagname> # внешний
```

### Переход на тег
```Shell
git checkout -b <branch_name> v3.4
```
---
* ## Ускоряем работу с Git
### Если вы не хотите печатать каждую команду для **Git** целиком, вы легко можете настроить псевдонимы (*alias*) для любой команды с помощью **git config**. Вот несколько примеров псевдонимов, которые вы, возможно, захотите задать:
```Shell
git config --global alias.ch checkout
git config --global alias.br branch
git config --global alias.cm commit
git config --global alias.st status
```
### Это означает, что, вместо ввода **git commit**, вам достаточно набрать только **git cm**. По мере освоения **Git** вам, вероятно, придётся часто пользоваться и другими командами. В этом случае без колебаний создавайте новые псевдонимы.
---

## Это были далеко не все команды, для вызова справки по командам можно набрать флаг **help**, после команды про которую хотим узнать
```Shell
git <command> --help
```

### Откладывание изменений
```Shell
git stash # откладываем изменения, кроме не отслеживаемых, 0 -> 1-> 2
git stash pop # возвращаем последнее изменение в каталог, 2-> 1-> 0
git stash list # показывает
git stash drop # удаляет
```
# А вот так работаем с командной строкой
## Смотрим наш текущий рабочий каталог
```Bash
pwd
```
## Смотрим список файлов
```Bash
ls
```
## Изменяем текущий рабочий каталог
```Shell
cd <dir>
cd..
```
## Создаем папку **folder**
```Shell
mkdir <folder>
```
## Создаем файл
```Shell
ni <file>
touch <file>
```
## Копируем файл
```Shell
cp <dir> <file>
```
## Переименовываем/перемещаем файл
```Shell
mv <file> <rename_file>
```
## Записываем в файл
```Shell
echo <text> > <file>
```

## Просматриваем содержимое файла
```Shell
cat <file>
```
## Удаляем файл/директорию
```Shell
rm <file>
rm -R <dir>
```