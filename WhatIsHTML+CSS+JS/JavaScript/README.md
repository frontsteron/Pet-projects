# Что такое JavaScript?

### Это динамический скриптовый язык программирования, который используют разработчики для создания интерактивных веб-страниц.

### **JavaScript** — это язык, который отличается следующими особенностями:

- ### **Высокоуровневый** - предлагает мощные и удобные средства для работы с данными различных типов,
- ### **Динамически типизированный** - типы переменных задавать необязательно,
- ### **Слабо типизированный** - это даёт больше гибкости, но из-за этого усложняются задачи проверки типов, потому что значения могут конвертироваться автоматически,
- ### **Интерпретируемый** - не нуждается в компиляции перед выполнением, но браузеры, для повышения производительности программ, выполняют компиляцию перед выполнением,
- ### **Мультипарадигменный** - писать можно, используя объектно-ориентированную парадигму, в функциональном и в императивном стиле.

### Подключаем скриптовый файл(**_JS_**) в теге **head**. Делаем отдельный файл чтобы не нагружать **html** документ(_чтобы было легче поддерживать код_) и чтобы быстрее загружались страницы.

```html
<head>
  <script src="script.js" defer></script>
</head>
<!--  с атрибутом defer скрипт выполнится когда будут загружены/созданы все теги(это более современный вариант, а в документе XHTML пишем атрубут defer="defer"). Атрибут async говорит, что можно продолжить загрузку страницы, не дожидаясь завершения загрузки сценария(в документе XHTML пишем атрубут async="async"). К в внешний URL JS файл подключаем с атрибутом integrity для безопасности/для проверки контрольной суммы -->
```

### Подключаем скрипты в **html** документ через тег **scrypt**, а в **xhtml** документ с разделом **cdata**, чтобы небыло синтаксических ошибок.

```html
<script type="text/javascript">
//<![CDATA[
  function compare(a, b) {
    if (a < b) {
        console.log("A is less than B");
    } else if(a > b) {
        console.log("A is greater then B");
    } else {
        console.log("A is equal to B");
    }
  }
//]]>
</scrypt>
```

### Вот так выглядит описание кода на русском языке.

```JavaScript
ключевоеСлово имяПеременной = значение;
```

---

## Синтаксис:

- ### Имена переменных(_идентификаторы_) и функций в **JS** начинаются с **буквы**, **$**, или с символа подчеркивания(**\_**), _могут даже содержать эмодзи или иероглифы_.
- ### **JS** чувствителен к регистру,
- ### Нотацию используем **camelCase**.

## В JS храним данные с помощью ключевых слов:

### Существует ключевое слово **let** и **const** для хранения данных. До ключеовго слова **let** использовали **var**, но сейчас оно является устаревшим, вместо него используем **let**.

- ### **let** - область видимости: блок(**\*var** область видимости: функция\*).
- ### **const** - область видимости: блок(**\*var** область видимости: функция\*).

### По умолчанию нужно использовать **const**, её обновить не можем, она хранит иммутабельные(_immutability_)/неизменныме переменные. При необходимости обновить значение переменной объявленной с помощью ключевого слова **let** - обновляем через простое равно(_оператор assign_(_=_)).

### Пример:

```JavaScript
let age = 20
age = 30
age = 40
```

## А вот зарезервированные слова, которые нельзя использовать в названиях имен переменных:

```JavaScript
break, do, instanceof, typeof, case, else, new, let, catch, finally, return, void, continue, for, switch, while, debugger, function, this, with, default, if, throw, delete, in, try, class, enum, extends, super, const, export, import, implements, let, private, public, interface, package, protected, static, yield
```

---

## Когда мы научись объявлять переменные, рассмотрим какие могут быть типы данных у этих переменных:

- ## **number** - числовой тип данных(_целые и дробные числа, примитивный тип_).

```JavaScript
const int = 1991;  // Целые числа
const decimal = 0.1991; // С плавающей точкой
const sameDecimal = .1991;
```

### Для конвертации(_явного преобразования_) различных типов данных в **число(_number_)**, используется встроенная в **JS** функция **Number()**.

### Пример:

```JavaScript
const yearBirth = '1991' // 1991(string)

console.log(Number(yearBirth)); // 1991(number)
console.log(Number(yearBirth) + 32); // 2023(number)
console.log(Number('Denis')); // NaN
console.log(Number(false)); // 0(number)
console.log(Number(true)); // 1(number)
console.log('19' - '9' - 1); // 9(number)
console.log('16' * '2'); // 32(number)
console.log('64' / '2'); // 32(number)
```

### Например, если к числу добавить строку, то строка будет преобразована в число и выполнится операция сложения.

### Явное преобразование к числу - **toNumber**

<details> 
  <summary style="font-size: 18px;">Встроенные методы(функции) к этому типу данных</summary> 
 
### **toFixed()** - возвращает число, округленное до заданного количества десятичных знаков и преобразованное в строку.

### **toPrecision()** - возвращает число в виде строки с указанной точностью (_количество значащих цифр_).

### **toString()** - преобразует число в строку.

### **valueOf()** - возвращает значение числа.

### **parseInt()** и **parseFloat()** - преобразуют строку в число с плавающей запятой (\*с учетом указанной базы для **parseInt()\***).

### **isFinite()** - определяет, является ли число конечным.

### **isNaN()** - определяет, является ли число **NaN** (_Not a Number_).

### **Math.abs(), Math.ceil(), Math.floor(), Math.max(), Math.min(), Math.pow(), Math.round(), Math.sqrt()** - методы объекта Math для выполнения математических операций с числами.

</details>

---

- ## **string** - строковый тип данных, используется для хранения текстовых данных/последовательности символов(_примитивный тип_).

```JavaScript
let single = 'Single quoted';
let double = "Double quoted";
```

### Если сначала переменной присвоить числовое значение, а затем, например, строковое, как в примере выше, то JS автоматически определяет, что переменная относится уже к другому типу данных, эти изменения делаются «_на лету_».

### Но, помните, что оператор конкатенации и метод `toString()` могут привести к неожиданным результатам, если вы не уверены в типе данных, который вы пытаетесь преобразовать. В этом случае, лучшей практикой является использование явного преобразования с помощью функции `String()`.

### Для конвертации различных типов данных в **строку(_string_)**, используется встроенная метод `toString()/String()` или оператора конкатенации `+`.

### Пример:

```JavaScript
let num = 31; // 31(number)

let str = num.toString(); // 31(string)
console.log(num); // 31(string)
console.log(typeof num); // выводит "string"

let str = num + ""; // 31(string)
console.log(num + 1991); // 311991(string)

console.log('19' + '9' + 1); // 1991(string)

let value = 123;
let str = String(value); // 123(string)

let bool = true/false;
let str = bool.toString(); // true/false

let bool = true;
let str2 = bool.toString(); // преобразует логическое значение в строку
console.log(typeof str2); // выводит "string"

let arr = [1, 2, 3];
let str3 = arr.toString(); // преобразует массив в строку
console.log(typeof str3); // выводит "string"

let obj = {name: "John", age: 25};
let str4 = JSON.stringify(obj); // преобразует объект в строку JSON
console.log(typeof str4); // выводит "string"

let str5 = "Hello, " + "world!"; // конкатенация двух строк
console.log(str5); // выводит "Hello, world!"
```

### Второй способ удобен для быстрой конкатенации строк, но для преобразования других типов данных рекомендуется использовать метод `toString()` или метод `JSON.stringify()` для объектов.

### Неявное преобразование к строке **string** + **num** = **string**

<details> 
  <summary>Встроенные методы(функции)</summary> 
 
### **length**: свойство, которое возвращает длину строки.

### **charAt(index)**: метод, который возвращает символ, находящийся по заданному индексу.

### **concat(str1, str2, ...)**: метод, который объединяет две или более строк.

### **includes(searchString, position)**: метод, который проверяет, содержит ли строка указанную входную подстроку.

### **indexOf(searchValue, fromIndex)**: метод, который возвращает индекс первого вхождения указанного значения в строку.

### **slice(start, end)**: метод, который извлекает часть строки и возвращает в виде новой строки.

### **toUpperCase()**: метод, который возвращает строку в верхнем регистре.

### **toLowerCase()**: метод, который возвращает строку в нижнем регистре.

</details>

---

- ## **boolean** - логический тип данных, может принимать значение **true** или **false**(_примитивный тип_).

```JavaScript
// Первый способ
const truthyValue = true; // Истина
const falsyValue = false; // Ложь

// Втрой спсособ
const truthyValue = Boolean(1); // Истина
const falsyValue = Boolean(''); // Ложь
```

### Преобразование к логическому типу - **Boolean**

```JavaScript
let let1 = NaN;
!!let1; // false
Boolean(let1); // false

let let2 = 'false'; // строка, любая строка кроме пустой '' -> будет true
!!let2; // true
Boolean(let2); // true

let let3 = false;
!!let3; // false
Boolean(let3); // false

let let4 = 0;
!!let4; // false
Boolean(let4); // false
```

### Явное преобразование - **toBoolean()**.

### string + boolean = string(_неявное преобразование_)

<details> 
  <summary style="font-size: 18px;">Встроенные методы(функции)</summary>

1. ### `Boolean()`: преобразует значение в логическое(**\*true** или **false\***).

```JavaScript
Boolean(0); // false
Boolean(""); // false
Boolean(null); // false
Boolean(undefined); // false
Boolean(NaN); // false
```

2. ### `&&` (`and`): возвращает **true**, если оба операнда равны **true**, в противном случае возвращает false.

```JavaScript
true && true; // true
true && false; // false
```

3. ### `||` (`or`): возвращает **true**, если хотя бы один из операндов равен **true**, в противном случае возвращает **false**.

```JavaScript
true || false; // true
false || false; // false
```

4. ### `!` (`not`): инвертирует логическое значение операнда.

```JavaScript
!true; // false
!false // true
```

</details>

---

- ## **null** - используется для указания на то, что значение переменной отсутствует(_примитивный тип_).

```JavaScript
const password = null;
```

---

- ## **undefined** - используется для указания на то, что переменная не имеет значения(_примитивный тип_).

```JavaScript
let name;
```

### string + undefined = string

---

- ## **object** - объекты, массивы, функции, и другие объекты; это наиболее важный тип данных, который формирует строительные блоки для современного **JS**(_ссылочный тип_).

```JavaScript
// Object: представляет комплексный объект! Но о нём немножечко позже.
```

### _PS.Обратите внимание на то, что все значения созданные с помощью ключевого слова new всегда имеют тип “**object**”. Исключением из этого является только конструктор **Function**._

<details> 
  <summary style="font-size: 18px;">Встроенные методы(функции)</summary>

### **Object.keys(obj)** - возвращает массив строк, представляющих все ключи объекта.

### **Object.values(obj)** - возвращает массив значений всех свойств объекта.

### **Object.entries(obj)** - возвращает массив массивов, каждый из которых содержит ключ и значение свойства объекта.

### **Object.assign(target, ...sources)** - копирует свойства объектов sources в объект target.

### **Object.freeze(obj)** - замораживает объект, так что его свойства нельзя изменять или удалять.

### **Object.seal(obj)** - запечатывает объект, так что вы не можете добавлять или удалять свойства, но вы можете изменять существующие.

### **Object.create(proto, [propertiesObject])** - создает новый объект с заданным прототипом и необязательными свойствами.

</details>

---

- ## **symbol** - уникальный и неизменяемый тип данных, используемый для создания уникальных идентификаторов(_примитивный тип_).

```JavaScript
const symOne = Symbol();
const symTwo = Symbol();

console.log(symOne === symTwo); // Ложь
```

<details> 
  <summary style="font-size: 18px;">Встроенные методы(функции)</summary>

### **Symbol()** - создает новый уникальный символ.

### **Symbol.for(key)** - создает символ с заданным именем и возвращает его. Если символ с заданным именем уже существует, возвращает ссылку на него.

### **Symbol.keyFor(sym)** - возвращает имя символа, созданного с помощью метода Symbol.for. Если символ был создан с помощью метода Symbol(), то вернется undefined.

### **Symbol.iterator** - используется для создания итераторов в JavaScript.

### **Symbol.toPrimitive** - используется для настройки преобразования объекта в примитивное значение.

### **Symbol.asyncIterator** - используется для создания асинхронных итераторов в JavaScript.

### Symbol.hasInstance\*\* - используется для определения метода, который будет вызываться при использовании оператора instanceof для объекта.

### **Symbol.species** - используется для определения конструктора, который будет использоваться при вызове методов, возвращающих новый экземпляр объекта.

</details>

### _PS.Обратим внимание, что в отличие от некоторых других языков программирования, в **JS** нет отдельного типа данных для символов, символы представлены типом данных **symbol**. Кроме того, в **JS** есть тип данных **bigint**, который позволяет работать с числами произвольной длины, но он является экспериментальным и поддерживается не во всех браузерах. А ещё в **JS** примитивные типы данных передаются по значению, а не по ссылке._

### Это явно приводили типы, а неявного приведения типов в **JS** нужно избегать.

---

## Чтобы проверить типы данных, у нас есть оператор **typeof**.

```JavaScript
console.log(typeof "hello"); // "string"
console.log(typeof String("hello")); // "string"
console.log(typeof new String("hello")); // "object"

console.log(typeof -0); // "number"
console.log(typeof 0xff); // "number"
console.log(typeof Infinity); // "number"
console.log(typeof -Infinity); // "number"
console.log(typeof NaN); // "number"
console.log(typeof Number(34)); // "number"
console.log(typeof new Number(34)); // "object"

console.log(typeof true); // "boolean"
console.log(typeof false); // "boolean"
console.log(typeof new Boolean(true)); // "object"

console.log(typeof undefined); // "undefined"

console.log(typeof null); // "object"

console.log(typeof Symbol()); // "symbol"

console.log(typeof []); // "object"
console.log(typeof Array(5)); // "object"

console.log(typeof function() {}); // "function"
console.log(typeof new Function); // "function"

console.log(typeof new Date); // "object"
console.log(typeof /^(.+)$/); // "object"
console.log(typeof new RegExp("^(.+)$")); // "object"
console.log(typeof {}); // "object"
console.log(typeof new Object); // "object"
```

| значение             | typeof                |
| -------------------- | --------------------- |
| `undefined`          | `'undefined'`         |
| `null`               | `'object'`            |
| `true` or `false`    | `'boolean'`           |
| all numbers or `NaN` | `'number'`            |
| all strings          | `'string'`            |
| all symbols          | `'symbol'`            |
| all functions        | `'function'`          |
| all arrays           | `'object'`            |
| native objects       | `'object'`            |
| host objects         | зависит от реализации |
| other objects        | `'object'`            |

---

## Функции:

### Функция в программировании - это блок кода, который может быть вызван из других частей программы. Функция нужна чтобы код был более читабельным и для повышения скорости написания программ(_то есть для повторного использования блока кода_).

### Код **JS** может принимать множество форм в зависимости от того, для чего он предназначен. Вот простой пример функции **JS**, которая возвращает сумму двух чисел:

```JavaScript
function sum(a, b) {
  return a + b;
}

let result = sum(3, 5);
console.log(result); // output: 8
```

### В этом коде мы определяем **функцию** с именем **sum**, которая принимает два параметра **a** и **b**, и возвращает их сумму. Затем мы вызываем эту функцию с аргументами 3 и 5, и присваиваем результат переменной с именем **result**. Наконец, мы записываем значение результата в консоль(_console.log_), которая выводит "8".

### Так же **JS** предоставляет широкий спектр встроенных функций, которые можно использовать для различных целей, например:

- **alert()** - отображает диалоговое окно предупреждения с сообщением и кнопкой OK.
- **confirm()** - отображает диалоговое окно предупреждения с сообщением и 2мя кнопками(_true & false_).
- **promt()** - отображает диалоговое окно, в котором можно ввести какой-то текст или данные.
- **console.log()** - записывает сообщение в консоль браузера или командную строку Node.js в целях отладки.
- **prompt()** - отображает диалоговое окно, в котором пользователю предлагается ввести данные.
- **setTimeout()** - вызывает функцию через заданное количество миллисекунд.
- **setInterval()** - повторяет вызов функции с заданным интервалом до тех пор, пока не будет отменен.
- **parseInt()** - преобразует строку в целое число.
- **parseFloat()** - преобразует строку в число с плавающей точкой.
- **Math.random()** - генерирует случайное число в диапазоне от 0 до 1.
- **Math.max()** - возвращает наибольшее значение из набора чисел.
- **Math.min()** - возвращает наименьшее значение в наборе чисел.

### Пример стрелочной функции в JavaScript:

```javascript
// Обычная функция
function multiply(a, b) {
  return a * b;
}

// Стрелочная функция
const multiplyArrow = (a, b) => a * b;

console.log(multiply(5, 3)); // Вывод: 15
console.log(multiplyArrow(5, 3)); // Вывод: 15
```

### Преимущества стрелочных функций:

1. ### **Краткость**: Стрелочные функции позволяют определить функцию в более краткой форме. Они особенно полезны для определения простых функций, которые выполняют одно действие.

2. ### **Лексическое окружение**: Стрелочные функции наследуют лексическое окружение (значения переменных) из окружающего кода. Это означает, что они обращаются к переменным из внешней области видимости, что может сделать код более читаемым.

3. ### **Нет своего контекста this**: В стрелочных функциях отсутствует собственный контекст `this`. Вместо этого, они используют контекст `this` из окружающего кода. Это устраняет проблемы с `this`, с которыми можно столкнуться в обычных функциях.

### Пример использования стрелочной функции для обработки массива:

```javascript
const numbers = [1, 2, 3, 4, 5];

// Обычная функция
const squaredNumbers = numbers.map(function (number) {
  return number * number;
});

// Стрелочная функция
const squaredNumbersArrow = numbers.map((number) => number * number);

console.log(squaredNumbers); // Вывод: [1, 4, 9, 16, 25]
console.log(squaredNumbersArrow); // Вывод: [1, 4, 9, 16, 25]
```

### В этом примере стрелочная функция делает код более кратким и читаемым, а также использует контекст `this` из окружающего кода, что обычно бывает удобным при работе с обработкой данных.

### Но это лишь небольшая подборка из множества функций, доступных в **JS**. Существует множество других функций и библиотек, которые можно использовать для самых разных целей, от манипулирования строками и массивами до выполнения сложных вычислений или взаимодействия с веб-интерфейсами.

---

## Условные выражения

### **JS** имеет несколько типов условных выражений, которые можно использовать для проверки условий и выполнения соответствующих действий. Некоторые из наиболее распространенных типов условных выражений в **JS** включают в себя следующее:

- ### **if/else** - позволяет выполнять код в зависимости от значения логического выражения. Если выражение истинно, то выполняется код в блоке **if**, иначе выполняется код в блоке **else**:

```JavaScript
if (expression) {
    // выполняется, если expression истинно
} else {
    // выполняется, если expression ложно
}
```

- ### **switch/case** - позволяет выполнять различный код в зависимости от значения переменной. Если значение соответствует одному из **case**, то выполняется соответствующий блок кода, который заканчивается ключевым словом **break**:

```JavaScript
switch (letiable) {
    case value1:
        // выполняется, если letiable равно value1
        break;
    case value2:
        // выполняется, если letiable равно value2
        break;
    default:
        // выполняется, если letiable не равно ни одному из значений cases
        break;
}
```

- ### тернарный оператор - позволяет выполнять различный код в зависимости от условия. Если условие истинно, выполняется первый блок кода, иначе выполняется второй блок кода:

```JavaScript
condition ? trueBlock : falseBlock;
```

- ### логические операторы **(&& и ||)** - позволяют объединять логические выражения и выполнять код только при их выполнении:

```JavaScript
if (a && b) {
    // выполняется, если истинны и a и b
}

if (a || b) {
    // выполняется или a или b
}
```

---

## Циклы JS

### Используются для повторения выполнения блока кода несколько раз. Они позволяют автоматизировать и ускорить выполнение повторяющихся задач. **JS** предоставляет несколько типов циклов:

- ### **for** - позволяет указать начальное значение, условие продолжения и шаг в цикле, и это является наиболее распространенным типом цикла, он используется для выполнения блока кода определенное количество раз.

```JavaScript
for (начальноеЗначение/инициализация; условие/проверка; шаг/инкремент) {
  // Блок кода, который нужно выполнить
}

// Пример демонстрирует использование цикла for для вывода чисел от 0 до 9 в консоль:
for (let i = 0; i < 10; i++) {
  console.log(i);
}
```

### _PS.Здесь начальноеЗначение - это начальное значение счетчика цикла, условие - это логическое выражение, которое проверяется перед каждой итерацией цикла, шаг - это операция, которая выполняется после каждой итерации._

- ### **while** - выполняет блок кода, пока указанное условие верно.

```JavaScript
while (условие) {
  // Блок кода, который нужно выполнить
}

// пример цикла while
let i = 0;
while (i < 10) {
  console.log(i);
  i++;
}
```

- ### **do-while** - выполняет блок кода один раз, а затем продолжает его выполнение, пока условие верно. Похож на цикл **while**, но он гарантирует, что блок кода будет выполнен хотя бы один раз.

```JavaScript
do {
  // Блок кода, который нужно выполнить
} while (условие);
```

- ### **forEach()** - используется для выполнения определенных действий над каждым элементом в массиве.

```JavaScript
// пример цикла forEach
let array = [1, 2, 3, 4];
array.forEach(function(item) {
  console.log(item);
});
```

- ### **map()** - используется для изменения каждого элемента массива и создания нового массива на основе этих изменений.

```JavaScript
// пример цикла map
let array = [1, 2, 3, 4];
let newArray = array.map(function(item) {
  return item * 2;
});
console.log(newArray);
```

- ### **reduce()** - используется для обработки элементов массива и вычисления единственного значения.

```JavaScript
// пример цикла reduce
let array = [1, 2, 3, 4];
let sum = array.reduce(function(total, item) {
  return total + item;
}, 0);
console.log(sum);
```

### _PS.Директива **break** может быть использована в любом из этих типов циклов для прерывания работы цикла при определенных условиях._

---

## Операторы:

- ## **=** - оператор присваивания;

## Арифметические операторы:

- ### **+** - сложение/конкатинация
- ### **-** - вычитание
- ### \* - умножение
- ### **/** - деление
- ### **%** - остаток от деления
- ### **++** - инкремент
- ### **--** - декремент
- ### ** - возведение в степень (5** 2 вернет 25)

```JavaScript
let a = 16;
let b = 4;

console.log(a + b); // 20
console.log(a * b); // 64
console.log(a % b); // 0
console.log(a ** (b/2)); // 256
```

---

## Операторы присваивания и арифметических действий:

- ### **+=** – для прибавления значения;

- ### **-=** – вычесть правое значение из левого;

- ### **\*=** – умножить на операнд(_аргумент операции/данные, которые обрабатываются командой_);

- ### **/=** – разделить и записать значение в правый операнд.

### Пример:

```JavaScript
let one = 1;
let two = 2;
two += one; // 3

let three = 3;
three -= one; // 2

let four = 4;
four *= two; // 8

let eight = 8;
eight /= two; // 4

console.log(two, three, four, eight); // 3 2 8 4
```

---

## Присваивание с битовыми операциями:

- ### **AND** (**&=**) – побитовое "И" выполняет "И" с каждым битом правого и левого операнда, записывая значение в правый операнд;

- ### **XOR** (**^=**) – побитовое исключающее "ИЛИ" по аналогии выполняет побитно исключающее "ИЛИ", результат в правом операнде;

- ### **OR** (**|=**) – побитовое "ИЛИ".

### Пример:

```JavaScript
let and = 101;
and &= 100;
console.log(and); // 100

let xor = 101;
xor ^= 10;
console.log(xor); // 111

let or = 100;
or |= 10;
console.log(or); // 110
```

---

## Операторы сравнения(_с общим(приведенным) и с разным(без приведенного) типом переменных_):

## С приведением типа переменных к одному:

- ### **==** – равно, можно сравнить число и строку;
- ### **!=** – неравно, можно сравнить число и строку;
- ### **>,>=** – больше/больше или равно. Возвращает true, если левый операнд больше/или равен;
- ### **<,<=** – меньше/меньше или равно. Возвращает true, если левый операнд меньше/меньше или равен.

### Пример:

```JavaScript
console.log(false == 0); // true
console.log('2' != 2); // false
console.log('5' > '3'); // true
console.log('2' < true); // false
```

## С разными(_без приведенных_) типами переменных:

- ### **===** – строго равно, если операнды равны по значению и по типу;

- ### **!==** – строго неравно, при разных операндах или их типах.

### Пример:

```JavaScript
console.log(1 !== 0); // true
console.log('2' === 2); // false
```

---

## Логические операторы

### Где результатом будет либо **false**, либо **true**.

- ### **||** – оператор "или", возвращает true, если хотя бы один из элементов true.
- ### **&&** – оператор "и", возвращает true только в том случае, если оба элемента true, иначе – false.
- ### **!** – оператор "не". Инверсия элемента(_при true – вернет false_)

### Пример:

```JavaScript
let a = true;
let b = 0; // false

console.log(a && b); // 0
console.log(b || a); // true
console.log(!b); // true
```

---

## Строгий режим:

### Строгий режим включается путем добавления строки "_use strict_" в начало **JS** файла или функции.

```JavaScript
"use strict" // для безопасности
```

### **Строгий режим**(_strict mode_) - это режим современного **JS**, который является более строгим и ограничительным. Он гарантирует, что код будет выполняться и интерпретироваться в более однозначном и предсказуемым способом. Так же включает дополнительное соблюдение правил и стандартов языка, и отключает или приводит к ошибкам некоторые функции, которые могут вызвать проблемы в стандартном режиме. Например, в стандартном режиме, использование необъявленных переменных может работать без выдачи ошибок, в то время как в строгом режиме это вызовет ошибку. **Strict mode** облегчает оптимизацию кода JS-движками и заставляет программиста осторожно обращаться с зарезервированными словами.

### Стандартный режим(_sloppy mode_) в **JS** и не является таким ограничительным, как режим '**strict**'. Это может быть полезно в некоторых случаях, но может и привести к определенным проблемам, таким как использование необъявленных переменных.

### **Преимущества** использования строгого режима включают:

- ### Запрет на использование необъявленных переменных, чтобы убедиться, что все переменные, которые вы используете, были объявлены.
- ### Устранение некоторых недопустимых действий, таких как удаление свойств, которые не могут быть удалены, или объявление функций в блоках кода, которые могут вызвать проблемы совместимости.
- ### Устранение некоторых недопустимых действий, таких как удаление свойств, которые не могут быть удалены, или объявление функций в блоках кода, которые могут вызвать проблемы совместимости.
- ### Устранение некоторых недопустимых действий, таких как удаление свойств, которые не могут быть удалены, или объявление функций в блоках кода, которые могут вызвать проблемы совместимости.

### Кроме того, использование строгого режима считается хорошим тоном в современном **JS**, поскольку он помогает предотвратить ошибки и делает код более читабельным и понятным.

---

### Если в **JS** нужно проверить, что определенный участок кода работает должным образом и выводит правильное значение, то можете использовать **console.log()**, этот метод выводит сообщения и отладочную информации в консоль браузера или разработчика.

---

## Исключения

### После изучения всего написанного - пришло время для [Codewars](https://www.codewars.com/)/[Hackerrank](https://www.hackerrank.com/)/[Coderbyte](https://coderbyte.com/)/[Leetcode](https://leetcode.com/)/[Edabit](https://edabit.com/) - это платформы для изучения и практики программирования, обычно такую практику называют **ката**. Ката может помочь улучшить навыки кодирования и изучить новые алгоритмы и методы.

### В общем и целом, это ценные ресурсы для программистов, позволяющий им совершенствовать свои навыки и получать практический опыт решения сложных задач программирования.

---

## **Ошибки**

### **Исключения в JS** используются для обработки ошибок, которые могут произойти во время выполнения программы. Они позволяют программисту **предусмотреть** возможные ошибки и обработать их с помощью блоков `try-catch`, чтобы предотвратить сбои в работе программы и улучшить отладку кода. Блок `try` **содержит код**, который может привести к ошибке, а блок `catch` **перехватывает** и **обрабатывает ошибки**.

### Вот пример использования блоков `try-catch` для перехвата и обработки ошибок в **JS**:

```JavaScript
try {
  // выполнение кода, который может привести к ошибке
  const result = 1 / 0;
} catch (error) {
  // обработка ошибки
  console.error(error.message);
}
```

### В этом примере блок `try` содержит код, который пытается выполнить деление на ноль, что приведет к ошибке. Если произойдет ошибка, блок `catch` перехватывает ее и выводит сообщение об ошибке в консоль.

### Использование исключений позволяет более гибко управлять ошибками в вашем коде и предотвращает получение некорректного результата при возникновении ошибок.

## Типы исключений:

1. ### `EvalError` - возникает при ошибках в функции **eval()**.
2. ### `RangeError` - возникает при выходе за границы допустимого диапазона значений.
3. ### `SyntaxError` - возникает при синтаксических ошибках в коде.
4. ### `TypeError` - возникает при несоответствии типов данных в операциях(_например, при попытке применить свойство или метод к переменной, которая не является объектом_).
5. ### `URIError` - возникает, когда функция URI(_например, decodeURIComponent_) вызывается с неправильным параметром.
6. ### `ReferenceError` - возникает при попытке обратиться к несуществующей переменной или функции.

### Кроме того, в **JS** также есть общие исключения, такие как `Error`, которые могут возникнуть в любых ситуациях, когда выполнение кода не удалось или прервалось по какой-то причине.

### Пример:

```JavaScript
try {
  // код, который потенциально может выдать исключение
} catch (e) {
  // обрабатываем исключение
  console.log('An error occurred: ' + e.message);
}
```

### В данном примере, выполняется попытка выполнить код, который может привести к возникновению исключения, а затем этот код помещается в блок **try**. Если исключение происходит в блоке **try**, управление передается в блок **catch**, где можно обработать исключение или вывести ошибку.
